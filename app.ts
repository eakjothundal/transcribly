// COMMAND TO RUN
// npx tsx app.ts

import { transcribe } from "./transcribe";
import { summarize } from "./summarize";
import dotenv from "dotenv";

dotenv.config();

const tempTranscript =
  "Initially. Right? Right. So a good example of this would be, like, I mean, really just this. Right? Like, the setting event. We're gonna we're gonna create a setting event. However, we don't have the answer upon creation of who will implement, how we'll implement, and when we'll implement. Right? So we left those optional true because it might be created with a blank value. Okay. So we're saying it's not required to validate this as a new item. Okay. And we wouldn't wanna empty string it either just to have, like, those place No. No. Because some of our UI will check if the value exists yet. Okay. I think that makes sense. Got it. But, like so and even though, like, an empty string will count as, like, not defined Mhmm. So I guess, theoretically, like, that could be okay. I feel like this is foolproof. I like the optional better. It does make sense. Well, with yours, it makes sense that I think most of them will be optional because I think they'll be creating those as they go with empty values. Right? Okay. Because you're gonna have that for environmental, they need to be able to, like, add another week, add another week, add another week. And every time they do that, they need to post another one of these data points and post it with all of those row values empty. So that I think that definitely makes sense there. I saw that your updates there were good. And then, yeah, and then here, everything apart from the base is optional. Mhmm. Because you gotta remember I remember that one. And then so then if you go back here now the reason that I would I had that backwards and, like, these actually, when you're defining this extension, you must say these are optional or or required. Okay. This is because we're going to have, like so you could say data's so you can, like 2 2 things to note about story provider. Story provider itself, when you create when you say, like, use story provider, notice that story provider receives a type generic. Alright? And if we go down to the hook, we'll see that the context takes in that same type generic. So what this means is, like so, for example, the default story type. Right? So if you just say use story provider and then you need to check intervention type on your story, you're gonna get, like, a type error that says intervention type does not exist on type item story because it exists on the story extension for type intervention. Mhmm. Type intervention has the key intervention type. So you can call story provider and say, like, use story provider and then got a schema item, food, story intervention. And now when you pull your story out of this hook instance, you're not gonna get a type error because you're saying the story that's in the provider is an item story intervention. Okay? But notice how, like, this extension, this got built from the the extension file. Mhmm. And intervention type is required on the story type of intervention. So if we did not make it required true on the type that it was exporting, anytime that we cast something as that data point type, it's gonna be like, this is possibly undefined. Got it. Okay. So if you if you go to Oh, gosh. Sorry. What's that here? My nose moving. Very good. Alright. So if I go to share composed components tier 3, still progress monitoring Data point card. No. Forms, I think, is where I'm gonna look. Alright. So here's a good example. Look at how this data point reference here. I'm saying I'm making I I found the existing data point. Right? Mhmm. And which is coming in through props, but, externally, I just found it by the metric and then I passed it in. But notice how, like, the moment that I needed to start doing stuff like data ref feels sad. I can't just do existing data point feels sad because existing data point is gonna be of type item data point. Got it. Right? Which only has the base properties. Right? Exactly. So I made an internal reference, and I said, well, actually, we're gonna make a data ref, and then this is built from the item that we built in that. And this knows that feel sad exists and is required for this data type. So that way, I don't need to make checks that feel sad exists because the type says it's required. I don't need to get type errors that doesn't exist off on this type because I that, like, this particular one is of this extension. You're gonna have to do this, for Fidelity chart. And I think the reason that this 4 is that generic comes down to this fact right here that the hook here is grabbing them. Right? We have, like, the metric name, but then it's off of the type again. Yeah. So this could be a number of them that it returns the different data points. It's like there's some type mapping there. However, I think you kinda see, like, the point. Right? Yeah. Is that you're in this extension file, you're defining not the requirements for open API because open API is never really gonna see this because it's not on the base. So if we go to host data port data port reads. Should we not try the discriminators in here? Okay. Yeah. So okay. Yeah. Yeah. So when it comes to the validation of, like, what's required to post, we define that in this array right here. So saying on the item definition that this is required, you're not necessarily telling it when somebody posts this, it's required in the body. You're saying that when somebody types this item, it's required in type. Got it. You need something to be required on the post. That's why we can spread all of these in here. All of them say required true on their extension type, but it's not being validated by open API on the post body because we told it these are the only things that are required, and you can only ever require things from the base. If you ever put a require like, a a key from the the the extensions in that array, you will break it for everything that is not that extension type. Makes sense. So, yeah, that's and then you also need to remember to add it to any of so that the returns are possible. So when we get into, like, these types for extensions on the front end, we do end up with, like, a lot of, like, casting and workarounds like the one that I showed you in that progress form. Mhmm. But, overall, it's not not too bad once you kind of, like, see what's occurring there. No. That was one of the most helpful walk throughs that I think I've had because I've seen those types, and I'm like, I don't know when I'm gonna use these. And now it makes sense where it all comes from and why to use them. So super appreciate that. While we're on this screen, I had another question kind of around this. Hold on one second. Yep. I just this is such a nightmare, man. Simultaneously, I got Moe, like, just in a sea of weeds trying to figure out how to make this section. I need you to reach out to Moe. Yeah. No. I could definitely pick that up. Like, look at this. Like, he's like, basically, like, if you just look at this, he's like I sent him, like, a massive message on, like, how the pattern kinda works at a high level. And, like, he's looking at this design. He's looking at my notes, and he's just like, I don't think that this will be possible given the composed components and the pattern and stuff. I'm like, dude, no. A 100000 percent possible. We have, like, 5 sections that look exactly like this. Yeah. The behavioral support chart looks pretty much like this. Yeah. So I'm gonna actually tell him Yeah. It looks like we're bringing the learn section almost exactly how I built it into CST 2. So I also like, I don't think we have the time to really sit down and be like, okay. This is how we'll adapt the learn section to work in both places, but I also feel like there might be some duplicated work happening because they're using the learn almost exact it's just blue instead of green now, and then there's just a couple different sections. But they should just use your learn section? Yeah. It just doesn't have this exact piece in it. But I've seen them, like, have other pieces. Like, one, the document grid, that's just gonna be used everywhere. But then there's things like video with rich text or video with playlist. Like, this is more This is under the do section, what I just put in the screenshot. Yeah. I've done just talking to the other ones. Like, I've helped, Rafael build a section for CST too that, like, lives in kinda, like, this learn area. But, yeah, I see that design is kind of reusing that concept there. And I mean, they need to build they need to build on top of your learn section then. Like, that's where you need to get them supported on on that. So, like, don't let them build, like, the same exact learn section. Mhmm. You know, the same way that you had, like, in include the different things for learn Mhmm. Like this like, these additions should be just, like, another thing that they could or choose to include or not include in their learn section. Right. I mean, we can make more learn sections, but what I don't wanna see is that, like, to your point, like, the same code being coded over and over and over again. Right. Like, above this do section right here I can't react. Above this do section, is it a learn section on this page too? I don't know. I just got this screenshot from Moe. Gotcha. So I didn't I didn't I haven't seen the whole design, and I gotta hop. But I told him I just told him, I'm like, I'm finishing up the sync with DJ. He's gonna reach out to you. We have components for almost all of this. Kinda wish Alec was here because he did a section very much like this also where he was, like, also, like, he could add more tabs and but, ideally, you can get them to use the tab. Like, they oh my gosh. I mean, I just built the tabber more. I just wish I just wish that there was, like, more time to, like, get the team trained up Mhmm. And not have them, like, thrown in the deep end like this. Like, from an outside of tech perspective, it's like they're like, yeah. We saw it over there. You're in tech. Make the same thing you made over there, but they don't get and not like they need to get. It's on us to get the whole team up to speed. But this is something that you or Alec would turn out in a day, and I feel like it's gonna take days for them to get locked down on, like, how to make something like this that fast. Yeah. And, like, Moe and marketing, they're gonna import mantine a lot. Yeah. Stop them. Stop them. Stop them. Mhmm. Make sure that they're using generics. They don't understand the broader issue with Mantine and our versioning and how generic components is our future solution to updating Mantine. Mhmm. We can't let shared get all fucked up on people not knowing why we're doing a thing that we say they have to do. If they want if there's any pushback, you'd be like, look. This is not just a preference. This is part of a larger issue that we need to use these generics. If there's not a generic component for an isolated generic part from mantine, make that generic component and use that. It it can start off basic. That's fine. However, like, mantene is not to be imported to anywhere outside of generic components unless it is box, loader, or show notification. Those are the only three things that I'm personally good with seeing get imported outside of form components or generic components. Because otherwise, like, we are just making the issue. We're drawing the issue out longer. Yeah. Gosh. I'm I just kind of wish that there was more awareness to, like, what's trying to change here, because like, as far as, like, practices and how there's only a few people that know this. Like, there needs to be dedicated time for me to, like, make walk throughs, SOPs, do a dev shadow Yeah. All that stuff, and then dump this work on everybody. Yeah. But, like, it's rough. It's rough. So, anyways, all that being said, how are we looking on this that we synced up for? Are you good there? I just have a couple other quick questions if we could rapid fire those if you're okay with that. Yeah. Yep. Let's do it. Okay. So, okay. So on this part with the, extension, are we okay typing things like this? I I've only seen other ones in extensions be, like, the basic, types, like string, Boolean, a number, things like that. Are we okay typing like so this one is just like the yes, no skip. That's all this one is. But I was like, should this be string at this point? I know we can't type those like this in the validator. Like, it has to be a string or a number or something. But I was wondering where we would wanna define No. No. No. No. Well, actually, no. Let's take a step back go back into the validator. My validator does support enums. So, like, for type, you would basically put your enum as the type. And there might even be an example of that in data point. Go to the top. Yeah. Look at line 23. Okay. So I have this as a type. I need to make it an enum. Yes. You do need to make it an enum. Got it. And, remember that all enums and I gotta get more formal on, like, how we name things. I slip sometimes and everything like that. I I'm supposed to be. Yeah. Sorry. Enums enums should always end in the word enum. Okay. Type should always end in the word type. Got it. Okay. And reason is is because then you can use, like, the same exact name and create alignment. And to be honest, the biggest misstep on this that I let get out of hand that I did, we all do now and everything, is that our descriptors all those descriptor files should end in the word descriptor. Because right now, they have the same exact name as the section or the component, and that's confusing. Right? That's what this is the same exact reason why in the new pattern, I was like, all of our section components need to end in the word section. Mhmm. Because the component will be named exactly either named after the product or named after the component that it's made a dedicated section for. Right. So we ended in section, so we can tell the difference when we're looking at changes to the files. And the descriptor file should be the same, because right now, you look at a descriptor file, and it's hard to tell that you're looking at a descriptor file unless you catch that you're in that directory. Right. And those files end in descriptor, so we know this is a descriptor file. Same reason that we end files with types. It's, you know, it's it's just that all over again. But enums always end in the word enum. The only thing that you gotta be aware of is that where you add this enum is important because if you hit me with a shift command e Shift command e. And then You see right above so look. Right above the in your explorer, right above item is enums. Boom. Add it to data point enums. Got it. Okay. And export it from there. Got it. Any enums to support open API schema types needs to go in here Okay. And export from here. They're not everywhere. Like, you're gonna find random ones that are not here. Mhmm. That's a bummer, but that's not what we wanted to do. We need to separate our concerns. And, of course, if there's not a file for the model that you're writing that Enum for, create it. Like, we have these 4 files here for these 4 schemas. But in the future, and if we're refactoring, make a new file. No general Enum files Okay. Scoped. And this way, we can always anticipate that because you're gonna need here's the thing. If you're gonna make that a type enum and not a type string, you will always have to import that enum when you're on the front end Got it. When you're assigning those values. Okay. Because open API will build it and identify the fact that this is not like a string even though it's a string enum. It will know that this is the t three environmental progress monitor type enum Right. Data. It'll it'll know it's that that you named right there. So, like, it even if you put a valid value, it will know. Got it. And, also, just to be clear, the reason that we don't use types, even though it's, like, that would be fine on the front end, like, using a type to be like, it could be this or this or this. Leave those practices internal to the front end mostly when we when possible. Okay. Reason being is because we can't we can't validate a type. Like like, I can't like, in that validator function, you can't access the option values of a type. Got it. Okay. That makes sense. Got it. So, like but you can in enum because an enum is an enumerated object. Got it. Okay. So when you when you access an enum, you can actually access the values of that enum and do validations against it. You can't do that with a type in TypeScript. Got it. Okay. And then you could do something like includes on a enum too. Right? And you can't on a type? And that Correct. If you'd if all of the string all of the keys are unique, it's a string enum, and you do object dot values of that enum includes. Okay. There's a few enums are weird. I can get in a whole rabbit hole on them. They actually like, they're smart. They try to merge values and map them. So, like, you won't always see a one for one object when you break down an object that is an enum. So, like, CST theme CST theme colors is a good example of this, where you have multiple keys in that enum that are different keys but then have the same hex value. Mhmm. If you were to map out the keys and values of that enum, you'll notice that you have more keys than you have values. Got it. Because it merged the similar values, and it maps 2 keys to the same value. Got it. So they get very tricky. And then I actually have some helpers for this is why I have that helper in storybook to get our color options and our icon options because it actually turns it into arrays and maps out all of the values to allow the repetitive strings to be counted twice. Mhmm. So, yeah, that's, like, the high level. It believe it or not, it's actually a deeper rabbit hole of gotchas when you try to use enums and validations or use enums as options. But that's that's why the validator function supports in validating an enum versus validating a type. Got it. Okay. And then you said here, if I don't have this as a string, it's going to require that we import that enum every time and then do it that way. Right? So are when you say that, are you recommending this to be a string then, or is that way preferred? Honestly, here's what I would say. I would recommend making these a string. Okay. And then on your validator, put the enum. Okay. Because that'll make it easier so you don't have to import the enum in all of your forms and stuff on the front end. You can just do a string. Got it. But then when you post it to the front end, it'll get validated against your enum. Got it. Okay. Okay. That makes sense. Perfect. Alright. That that'll just be easier. Mhmm. I think that one could make an argument that using the the the enum is more typescripty and better. But because of how we validate, I think I'd rather just let the developers get the API errors and realize that they're leaving something that lets the user put an invalid value there. Yeah. That makes sense. So yeah. So that yeah. So, actually, yeah, to to your point or to your question, make those types strings and then make that enum that you create the validation type on the validator. Got it. Okay. Perfect. I hope this is a quick one, but I did notice in the model that it looks like these were the first two at the top too, so maybe it's just, like, left over from that. But I was just wondering why only 2 of the extensions are included in the model that's defined and not the rest of them. Is there a reason for that, or is it just kinda like a leftover? Does it impact anything? This is kind of just a funny NoSQL thing. If you add to the schema, it will it will validate that. If you don't add to the schema, documents will let you write whatever keys you want to a document. So we're putting trust in our validation methods to catch something that should not be written to the document. But it could kind of work with or without it. Like you like you pointed out, we have those 2 there. This this will call this will allow it to throw an error on the database if, because there's also I think that there's also, like, a required option on these. Right? Can you check? I believe there's a optional. So, like, entry No. Not on not on the validator, on the model. So, like, if you go down to where you just were, okay, and then, like, hit enter and just, like, start typing required. Yeah. So hit required. Yeah. So you see, like, you can say required true here, and then that will make and if you do require true, then Dynamo will throw an error if it's not there. Okay. But in in reality, it it just lets you write whatever you want. Got it. Okay. That makes sense. So we're we're really relying on these validators to do that part and then okay. Not too worried about this. So Yeah. Yeah. This is probably, like, prevalidator or something like that kinda added here. Yes. That was when we were experimenting when we didn't realize that, like I think at one point, I sent a bad key value pair to a model. I was like, why did it let me write that? And then I remembered, like, oh, this is no SQL. This is even more flexible in Dynamo or not Dynamo, Mongo. Mhmm. Like, Mongo, you can write, like, a fully different form that if you didn't hold it accountable to, like, it'll just accept that into the table and be like, no. Take it. I'll take it. I'll take it. Gotcha. Okay. That makes sense. It's a power if you wield it well. Mhmm. It's a vulnerability if you don't cover your bases, and it's just something that you kinda get good at or just be more aware of in in NoSQL space. Because, yeah, that's something that it was funny that you brought that up because, like, an hour ago when I was looking at this stuff before we synced, I went to the model, and I was like, oh, yeah. We gotta define these on the model too. Right? And then I got there. I was like, they're not there. And I was like, oh, yeah. We don't have to. Got it. Okay. Yeah. I didn't Yeah. Because I didn't see the rest of them there. And since there is this other Fidelity data 1, I've been kinda just like, okay. Where is this one kind of being referenced? And trying to, like, use that as at least as, like, a little guide. Where that fell apart was this last question, which is these 2 post and puts. It's not included in here. So the post, I guess, I was like, okay. Maybe that's a part of the template, and that's why maybe we don't post that fidelity data because it is all of these are required on here, for the session fidelity data. So I did add it in here for mine, for the environmental fidelity data, And I am spreading that in. But I didn't see the other one. And then in put, there's actually only a few. There's only these 4 that are passed through in the put open API, file. So and then I don't think I've spread it. Oh, yeah. That is. That one. Okay. But, yeah, just kinda wanna know what it does in this sense. So so, again, these are it's worth remembering that, like, this request body schema and that response body schema is essentially building a type. So it's not validating anything, unless, again, you put it under required Mhmm. Array. This is actually just incomplete Okay. What you're seeing. Because here's the thing. If I'm making a post request, right, and I need to post a a body for a data point and the keys of that body are not in that request body schema Mhmm. It's gonna throw me an error and say, like, these keys don't exist on my data schema. Let's see. Data schema v one organization, the story, story ID collection, c ID data body. Got it. And because it's it's giving you a type for the post payload. So basically, those post payloads are missing a lot of options. However, also worth noting, this you can just type cat. I I I think that the reason we stopped maintaining those bodies for extensions, or I did, was because either way, it started kinda getting picky about what wasn't there because of the true requirements Mhmm. On thing. And in the end of the day, I think you still end up just needing to to cast your payload as the body post as the body for that post request. So when you go to post it, you're gonna have to say or when you go to pass in the argument into, like, post data point, again, you're not gonna make this update in story provider. But in your handler, where you're using the post data point function from story provider, remember, you're gonna write a handler function inside of that form. Mhmm. In that form, you're going to cast your payload as data schema dot postvoneorganizationidstoryblahblahblahbody. Got it. And then it's and and then that way, the post data point is gonna be like, this is a valid post body. Okay. So we're not worried about it because, again, at the end of the day, there was so much rigmarole with something like data points that has so many extensions Right. That, like it's like this is so much to micromanage. And when you put that up against the just casting the body, it's like we can't and the reason again, like, the reason that we couldn't get it to work correctly is because of discriminators not seeming to work correctly in our custom implementation. So, like, a discriminator, which you could see our attempted implementation on the story endpoints. So, like, if on the left in your explorer, you collapse collection and then go into down go into post open API under story, not story ID. Yeah. No. You're just on it. Oh. Yeah. That one right there. Yeah. Alright? So you see how if you scroll down a little bit if it's still here. I might have even removed it. I see the screen reader somewhere. Yeah. Go into, actually, I think it's in the data schema still. But if you go down to data schema and then go to find story, go to model, Go down to the bottom. No. Not here. Wait. I might have ripped it out of more places than I thought. Gotcha. Go to yeah. Click click okay. So click no. Like, go go down. Look for a def okay. Go up. Go up to the top. Go to see that one where it says definition.ts? Click that one. Yeah. So schema's item collection is still was still trying to use it. So you have to use one of them, actually, to the one I was working on. Unfortunately, this mapping doesn't work correctly. Okay. And this is why this is how we ended up on validator. Like, it I think that, like, we're trying I'm I've been trying to keep adding and maintaining ones that are already trying to implement it, hoping that maybe one day we figure out what's wrong with discriminators in our setup. Got it. But, essentially, a discriminator is basically saying, like, look at this value property name type on the object that you get. If type equals and then the mapping is the key is the value on the left and then the the extension schema on the right or vice versa. No. That way. So, like, you're basically saying, like, if the value is progress monitor, then find the extension name, progress monitor name, and validate it against that. If it's interview and rating, then validate it against this. And you're basically at that point, you're able to use the required field because then you can actually do a similar discrimination on the required field in the schemas as well to change what's required based on this value changing the landscape of the type. Does not work no matter we spent, like, 2 days trying to get it to work, and it just it lets everything fly. Mhmm. It just doesn't do it. So, like but but in in open API, that's what discriminators are for, and they're supposed to work in, like, a normal, like, YAML setup and stuff. It's a little bit more complex, but I well, I was so bummed when it didn't work. Gotcha. That was actually the day that I that was actually the day that I wrote that validator function. Yeah. So that's that's kind of the what's what. No. That was so awesome, man. Yeah. Yesterday, I was just like, I just wanna dive into this and do what I think I have to do, and then kinda check-in with you and be like, hey. Was this right? I think, like, that's just a good way to for me to kinda learn this whole thing, like, the kind of I I did review your, draft PR. You got a you got, like, 99% of it right. You know? Like, you're good. Awesome. Yeah. Thanks, man. This has been awesome. Just, like, learning and getting into this world and seeing where things come from that I see in the code all the time. So, yeah, I appreciate you a ton, man. Yeah. We're gonna we're gonna complete this circle of knowledge, and, and, and, yeah, you'll you'll see. It's like it's it's weird. The more that you embrace the chaos and you kind of as in in the heart in the spirit of ash, I'll reiterate a throwback statement, ride the wave of entropy. You know, it it starts to make sense. And as it starts to make sense, you start to kinda slowly feel like I can flip and do anything. Yeah. It's like as long as you know how things are working, it unlocks a lot of power. So definitely definitely try to get your your powers unlocked in more spaces. And and I I just anytime I can make things make more sense for you, I wanna do that. Yeah. Yeah. Yesterday, when I was looking at this, I was like, man, I know Brian could probably hop into this and finish it in, like, 20 minutes, but he's just like, no. EJ wants to learn this kind of stuff, so he can go ahead and do it. And I appreciate that a ton, but I reached out to Jensen. I was like, you can add Slack emojis. Right? I was like, can we get this Brian emoji in there? And then, yeah, we gotta add it. Yeah. That was literally why. I was like, man, I I get to do all this stuff. And then as soon as I run into it, I'm just writing down a question. I know Brian's gonna go totally into this topic and make sure I understand it. So appreciate you time, man. Yeah. No. I've I've definitely made it also communicated to Willis. Like, I'm I I I can probably only make time for, like, one at a time to to get this type of, like, leveling up. And I'm like, you know, EJ is next in line. I gotta get EJ. You know, he's you're picking it up well. It's making sense. You're you're dedicated. You're, you know, highly motivated to break into new spaces. And I'm, you know, frankly sick and tired of being one of the few people who understands how all this works, especially with Ash leaving. Like, I don't want to be the only person knowing so many things. It's basically like me and Phyllis. And even when it comes to this, unfortunately, I know more than Phyllis now just because he hasn't worked in this and and and stories in the first place that we did all this. Yeah. You don't wanna become the next Ash where it's just bottlenecked. I sure as hell don't. Yeah. I don't. I I I I think I've said it before, and it's kind of like my mantra. This band has no lead singer. Yeah. You know? Like, I'm I'm not I'm not trying to be some superhero here. I'm trying to be on an I'm trying to be an Avenger. I'm not trying to be Superman. You know? Like Yeah. It's so, like, I need a I need Avengers to assemble. And if and if we gotta train, if we gotta, you know, get more knowledge, like, we are all like, I want us all to become powerhouses, and that involves all of us knowing what's what. So yeah, bro. I got you. As you find these gaps, let's fill them in. Let's keep you moving forward, and then we gotta get and then Alec will have both of us as a resource to get him up into some of these more complex spaces. And, you know, we haven't even gotten fully into, like, writing data points and data point scheme as yet, but that'll be a whole other, fun thing to go down one day because we have a lot of refactoring work on our API to to make it better. Hell, yeah. Yeah. Alright. Excited. Don't worry about the Moe thing. I'll reach out to him. I'll get that handled. So, yeah, don't stress out about that. I know you got a lot of permission stuff to figure out and roles and whatnot. So, yeah, I'll handle that with Mo. I'll reach out to him right now and get that solved. Perfect. Hopefully, he's expecting you. I I already told him, like, 20 minutes ago that you'll hit him up when we're done. So thank you so much, man. That means a lot. This is why this is why we're we're doing what we're doing, and and yeah. Really, really appreciate you, and the support even just with the Moe thing and growing in his spaces. Like, it's just I got nothing but, like, the highest positive things to say about EJ to anybody who wants to know.";

const app = async () => {
  // Transcription
  // console.log("-------- Transcribing --------");
  // const transcript = await transcribe();

  // Summarization
  console.log("-------- Summarizing --------");
  if (tempTranscript) {
    const summary = await summarize(tempTranscript);
    console.log(summary);
  }
};

app();
